import rggen::rggen_rtl_pkg::*;
pub module uart_csr #(
  param ADDRESS_WIDTH: u32 = 5,
  param PRE_DECODE: bool = false,
  param BASE_ADDRESS: bit<ADDRESS_WIDTH> = '0,
  param ERROR_STATUS: bool = false,
  param DEFAULT_READ_DATA: bit<32> = '0,
  param INSERT_SLICER: bool = false,
  param DLL_INITIAL_VALUE: bit<8> = 8'h00,
  param DLM_INITIAL_VALUE: bit<8> = 8'h00
)(
  i_clk: input clock,
  i_rst: input reset,
  apb_if: modport rggen::rggen_apb_if::slave,
  i_rbr: input logic<8>,
  o_rbr_read_trigger: output logic,
  o_thr: output logic<8>,
  o_thr_write_trigger: output logic,
  o_ier_erbfi: output logic,
  o_ier_etbei: output logic,
  o_ier_elsi: output logic,
  o_ier_edssi: output logic,
  i_iir_intpend: input logic,
  i_iir_intid2: input logic<3>,
  o_fcr_fifoen: output logic,
  o_fcr_rcvr_fifo_reset_trigger: output logic,
  o_fcr_xmit_fifo_reset_trigger: output logic,
  o_fcr_dma_mode_select: output logic,
  o_fcr_rcvr_fifo_trigger_level: output logic<2>,
  o_lcr_wls: output logic<2>,
  o_lcr_stb: output logic,
  o_lcr_pen: output logic,
  o_lcr_eps: output logic,
  o_lcr_stick_parity: output logic,
  o_lcr_set_break: output logic,
  o_lcr_dlab: output logic,
  o_mrc_dtr: output logic,
  o_mrc_rts: output logic,
  o_mrc_out1: output logic,
  o_mrc_out2: output logic,
  o_mrc_loop_back: output logic,
  i_lsr_dr: input logic,
  i_lsr_oe: input logic,
  o_lsr_oe_read_trigger: output logic,
  i_lsr_pe: input logic,
  o_lsr_pe_read_trigger: output logic,
  i_lsr_fe: input logic,
  o_lsr_fe_read_trigger: output logic,
  i_lsr_bi: input logic,
  o_lsr_bi_read_trigger: output logic,
  i_lsr_thre: input logic,
  i_lsr_temt: input logic,
  i_lsr_error_in_rcvr_fifo: input logic,
  i_msr_dcts: input logic,
  o_msr_dcts_read_trigger: output logic,
  i_msr_ddsr: input logic,
  o_msr_ddsr_read_trigger: output logic,
  i_msr_teri: input logic,
  i_msr_ddcd: input logic,
  o_msr_ddcd_read_trigger: output logic,
  i_msr_cts: input logic,
  i_msr_dsr: input logic,
  i_msr_ri: input logic,
  i_msr_dcd: input logic,
  o_scratch: output logic<8>,
  o_dll: output logic<8>,
  o_dlm: output logic<8>
){
  inst register_if: rggen::rggen_register_if[12]#(ADDRESS_WIDTH: 5, BUS_WIDTH: 32, VALUE_WIDTH: 32);
  inst u_adapter: rggen::rggen_apb_adapter #(
    ADDRESS_WIDTH:        ADDRESS_WIDTH,
    LOCAL_ADDRESS_WIDTH:  5,
    BUS_WIDTH:            32,
    REGISTERS:            12,
    PRE_DECODE:           PRE_DECODE,
    BASE_ADDRESS:         BASE_ADDRESS,
    BYTE_SIZE:            32,
    ERROR_STATUS:         ERROR_STATUS,
    DEFAULT_READ_DATA:    DEFAULT_READ_DATA,
    INSERT_SLICER:        INSERT_SLICER
  )(
    i_clk:        i_clk,
    i_rst:        i_rst,
    apb_if:       apb_if,
    register_if:  register_if
  );
  :g_rbr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    var indirect_match: logic;
    assign indirect_match = register_if[5].value[7+:1] == 1'h0;
    inst u_register: rggen::rggen_indirect_register #(
      READABLE:             true,
      WRITABLE:             false,
      ADDRESS_WIDTH:        5,
      OFFSET_ADDRESS:       5'h00,
      BUS_WIDTH:            32,
      DATA_WIDTH:           32,
      VALUE_WIDTH:          32,
      VALID_BITS:           32'h000000ff,
      INDIRECT_MATCH_WIDTH: 1
    )(
      i_clk:            i_clk,
      i_rst:            i_rst,
      register_if:      register_if[0],
      i_indirect_match: indirect_match,
      bit_field_if:     bit_field_if
    );
    :g_rbr {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 8);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:8];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:8];
        bit_field_if.read_data[0+:8] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:8] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              8,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_rbr_read_trigger,
        i_value:        i_rbr
      );
    }
  }
  :g_thr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    var indirect_match: logic;
    assign indirect_match = register_if[5].value[7+:1] == 1'h0;
    inst u_register: rggen::rggen_indirect_register #(
      READABLE:             false,
      WRITABLE:             true,
      ADDRESS_WIDTH:        5,
      OFFSET_ADDRESS:       5'h00,
      BUS_WIDTH:            32,
      DATA_WIDTH:           32,
      VALUE_WIDTH:          32,
      VALID_BITS:           32'h000000ff,
      INDIRECT_MATCH_WIDTH: 1
    )(
      i_clk:            i_clk,
      i_rst:            i_rst,
      register_if:      register_if[1],
      i_indirect_match: indirect_match,
      bit_field_if:     bit_field_if
    );
    :g_thr {
      const INITIAL_VALUE: bit<8> = 8'hff;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 8);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:8];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:8];
        bit_field_if.read_data[0+:8] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:8] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          8,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_READ_ACTION: rggen_sw_action::READ_NONE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        true
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  o_thr_write_trigger,
        o_value:          o_thr
      );
    }
  }
  :g_ier {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    var indirect_match: logic;
    assign indirect_match = register_if[5].value[7+:1] == 1'h0;
    inst u_register: rggen::rggen_indirect_register #(
      READABLE:             true,
      WRITABLE:             true,
      ADDRESS_WIDTH:        5,
      OFFSET_ADDRESS:       5'h04,
      BUS_WIDTH:            32,
      DATA_WIDTH:           32,
      VALUE_WIDTH:          32,
      VALID_BITS:           32'h0000000f,
      INDIRECT_MATCH_WIDTH: 1
    )(
      i_clk:            i_clk,
      i_rst:            i_rst,
      register_if:      register_if[2],
      i_indirect_match: indirect_match,
      bit_field_if:     bit_field_if
    );
    :g_erbfi {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_ier_erbfi
      );
    }
    :g_etbei {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:1];
        bit_field_if.read_data[1+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_ier_etbei
      );
    }
    :g_elsi {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_ier_elsi
      );
    }
    :g_edssi {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_ier_edssi
      );
    }
  }
  :g_iir {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       false,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h08,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h0000000f
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[3],
      bit_field_if: bit_field_if
    );
    :g_intpend {
      const INITIAL_VALUE: bit = 1'h1;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_iir_intpend
      );
    }
    :g_intid2 {
      const INITIAL_VALUE: bit<3> = 3'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 3);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:3];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:3];
        bit_field_if.read_data[1+:3] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:3] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              3,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_iir_intid2
      );
    }
  }
  :g_fcr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       false,
      WRITABLE:       true,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h08,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h000000cf
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[4],
      bit_field_if: bit_field_if
    );
    :g_fifoen {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_READ_ACTION: rggen_sw_action::READ_NONE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_value:          o_fcr_fifoen
      );
    }
    :g_rcvr_fifo_reset {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:1];
        bit_field_if.read_data[1+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field_w01trg #(
        TRIGGER_VALUE:  1'b1,
        WIDTH:          1
      )(
        i_clk:        i_clk,
        i_rst:        i_rst,
        bit_field_if: bit_field_sub_if,
        o_trigger:    o_fcr_rcvr_fifo_reset_trigger
      );
    }
    :g_xmit_fifo_reset {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field_w01trg #(
        TRIGGER_VALUE:  1'b1,
        WIDTH:          1
      )(
        i_clk:        i_clk,
        i_rst:        i_rst,
        bit_field_if: bit_field_sub_if,
        o_trigger:    o_fcr_xmit_fifo_reset_trigger
      );
    }
    :g_dma_mode_select {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_READ_ACTION: rggen_sw_action::READ_NONE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_value:          o_fcr_dma_mode_select
      );
    }
    :g_rcvr_fifo_trigger_level {
      const INITIAL_VALUE: bit<2> = 2'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 2);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[6+:2];
        bit_field_sub_if.write_data = bit_field_if.write_data[6+:2];
        bit_field_if.read_data[6+:2] = bit_field_sub_if.read_data;
        bit_field_if.value[6+:2] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          2,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_READ_ACTION: rggen_sw_action::READ_NONE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_value:          o_fcr_rcvr_fifo_trigger_level
      );
    }
  }
  :g_lcr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       true,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h0c,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h000000ff
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[5],
      bit_field_if: bit_field_if
    );
    :g_wls {
      const INITIAL_VALUE: bit<2> = 2'h3;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 2);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:2];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:2];
        bit_field_if.read_data[0+:2] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:2] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          2,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_wls
      );
    }
    :g_stb {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_stb
      );
    }
    :g_pen {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_pen
      );
    }
    :g_eps {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[4+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[4+:1];
        bit_field_if.read_data[4+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[4+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_eps
      );
    }
    :g_stick_parity {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[5+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[5+:1];
        bit_field_if.read_data[5+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[5+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_stick_parity
      );
    }
    :g_set_break {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[6+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[6+:1];
        bit_field_if.read_data[6+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[6+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_set_break
      );
    }
    :g_dlab {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[7+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[7+:1];
        bit_field_if.read_data[7+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[7+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_lcr_dlab
      );
    }
  }
  :g_mrc {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       true,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h10,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h0000001f
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[6],
      bit_field_if: bit_field_if
    );
    :g_dtr {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_mrc_dtr
      );
    }
    :g_rts {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:1];
        bit_field_if.read_data[1+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_mrc_rts
      );
    }
    :g_out1 {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_mrc_out1
      );
    }
    :g_out2 {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_mrc_out2
      );
    }
    :g_loop_back {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[4+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[4+:1];
        bit_field_if.read_data[4+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[4+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          1,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_mrc_loop_back
      );
    }
  }
  :g_lsr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       false,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h14,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h000000ff
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[7],
      bit_field_if: bit_field_if
    );
    :g_dr {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_lsr_dr
      );
    }
    :g_oe {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:1];
        bit_field_if.read_data[1+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_lsr_oe_read_trigger,
        i_value:        i_lsr_oe
      );
    }
    :g_pe {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_lsr_pe_read_trigger,
        i_value:        i_lsr_pe
      );
    }
    :g_fe {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_lsr_fe_read_trigger,
        i_value:        i_lsr_fe
      );
    }
    :g_bi {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[4+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[4+:1];
        bit_field_if.read_data[4+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[4+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_lsr_bi_read_trigger,
        i_value:        i_lsr_bi
      );
    }
    :g_thre {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[5+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[5+:1];
        bit_field_if.read_data[5+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[5+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_lsr_thre
      );
    }
    :g_temt {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[6+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[6+:1];
        bit_field_if.read_data[6+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[6+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_lsr_temt
      );
    }
    :g_error_in_rcvr_fifo {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[7+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[7+:1];
        bit_field_if.read_data[7+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[7+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_lsr_error_in_rcvr_fifo
      );
    }
  }
  :g_msr {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       false,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h18,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h000000ff
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[8],
      bit_field_if: bit_field_if
    );
    :g_dcts {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:1];
        bit_field_if.read_data[0+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_msr_dcts_read_trigger,
        i_value:        i_msr_dcts
      );
    }
    :g_ddsr {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[1+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[1+:1];
        bit_field_if.read_data[1+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[1+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_msr_ddsr_read_trigger,
        i_value:        i_msr_ddsr
      );
    }
    :g_teri {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[2+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[2+:1];
        bit_field_if.read_data[2+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[2+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_msr_teri
      );
    }
    :g_ddcd {
      const INITIAL_VALUE: bit = 1'h0;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[3+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[3+:1];
        bit_field_if.read_data[3+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[3+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            true
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: o_msr_ddcd_read_trigger,
        i_value:        i_msr_ddcd
      );
    }
    :g_cts {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[4+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[4+:1];
        bit_field_if.read_data[4+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[4+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_msr_cts
      );
    }
    :g_dsr {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[5+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[5+:1];
        bit_field_if.read_data[5+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[5+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_msr_dsr
      );
    }
    :g_ri {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[6+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[6+:1];
        bit_field_if.read_data[6+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[6+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_msr_ri
      );
    }
    :g_dcd {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 1);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[7+:1];
        bit_field_sub_if.write_data = bit_field_if.write_data[7+:1];
        bit_field_if.read_data[7+:1] = bit_field_sub_if.read_data;
        bit_field_if.value[7+:1] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:              1,
        SW_WRITE_ACTION:    rggen_sw_action::WRITE_NONE,
        STORAGE:            false,
        EXTERNAL_READ_DATA: true,
        TRIGGER:            false
      )(
        i_clk:          i_clk,
        i_rst:          i_rst,
        bit_field_if:   bit_field_sub_if,
        o_read_trigger: _,
        i_value:        i_msr_dcd
      );
    }
  }
  :g_scratch {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    inst u_register: rggen::rggen_default_register #(
      READABLE:       true,
      WRITABLE:       true,
      ADDRESS_WIDTH:  5,
      OFFSET_ADDRESS: 5'h1c,
      BUS_WIDTH:      32,
      DATA_WIDTH:     32,
      VALUE_WIDTH:    32,
      VALID_BITS:     32'h000000ff
    )(
      i_clk:        i_clk,
      i_rst:        i_rst,
      register_if:  register_if[9],
      bit_field_if: bit_field_if
    );
    :g_scratch {
      const INITIAL_VALUE: bit<8> = 8'h00;
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 8);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:8];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:8];
        bit_field_if.read_data[0+:8] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:8] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          8,
        INITIAL_VALUE:  INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_scratch
      );
    }
  }
  :g_dll {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    var indirect_match: logic;
    assign indirect_match = register_if[5].value[7+:1] == 1'h1;
    inst u_register: rggen::rggen_indirect_register #(
      READABLE:             true,
      WRITABLE:             true,
      ADDRESS_WIDTH:        5,
      OFFSET_ADDRESS:       5'h00,
      BUS_WIDTH:            32,
      DATA_WIDTH:           32,
      VALUE_WIDTH:          32,
      VALID_BITS:           32'h000000ff,
      INDIRECT_MATCH_WIDTH: 1
    )(
      i_clk:            i_clk,
      i_rst:            i_rst,
      register_if:      register_if[10],
      i_indirect_match: indirect_match,
      bit_field_if:     bit_field_if
    );
    :g_dll {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 8);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:8];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:8];
        bit_field_if.read_data[0+:8] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:8] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          8,
        INITIAL_VALUE:  DLL_INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_dll
      );
    }
  }
  :g_dlm {
    inst bit_field_if: rggen::rggen_bit_field_if#(WIDTH: 32);
    var indirect_match: logic;
    assign indirect_match = register_if[5].value[7+:1] == 1'h1;
    inst u_register: rggen::rggen_indirect_register #(
      READABLE:             true,
      WRITABLE:             true,
      ADDRESS_WIDTH:        5,
      OFFSET_ADDRESS:       5'h04,
      BUS_WIDTH:            32,
      DATA_WIDTH:           32,
      VALUE_WIDTH:          32,
      VALID_BITS:           32'h000000ff,
      INDIRECT_MATCH_WIDTH: 1
    )(
      i_clk:            i_clk,
      i_rst:            i_rst,
      register_if:      register_if[11],
      i_indirect_match: indirect_match,
      bit_field_if:     bit_field_if
    );
    :g_dlm {
      inst bit_field_sub_if: rggen::rggen_bit_field_if#(WIDTH: 8);
      always_comb {
        bit_field_sub_if.read_valid = bit_field_if.read_valid;
        bit_field_sub_if.write_valid = bit_field_if.write_valid;
        bit_field_sub_if.mask = bit_field_if.mask[0+:8];
        bit_field_sub_if.write_data = bit_field_if.write_data[0+:8];
        bit_field_if.read_data[0+:8] = bit_field_sub_if.read_data;
        bit_field_if.value[0+:8] = bit_field_sub_if.value;
      }
      inst u_bit_field: rggen::rggen_bit_field #(
        WIDTH:          8,
        INITIAL_VALUE:  DLM_INITIAL_VALUE,
        SW_WRITE_ONCE:  false,
        TRIGGER:        false
      )(
        i_clk:            i_clk,
        i_rst:            i_rst,
        bit_field_if:     bit_field_sub_if,
        o_write_trigger:  _,
        o_read_trigger:   _,
        o_value:          o_dlm
      );
    }
  }
}
